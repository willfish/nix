#!/usr/bin/env bash
# vim: sw=2 ts=2 noet:

usage() {
	cat <<-USAGE
Usage: $SCRIPT [<options>] [CONFIG_PATH]

Options:
  --help, -h            print this usage statement
  --merge, -m           merge the kubeconfig content into CONFIG_PATH (default)
  --no-merge, -M        overwrite the kubeconfig content in CONFIG_PATH
  --profile, -p         edit shell profile script (default)
  --no-profile, -P      do NOT edit shell profile script
  --shell, -s SHELL     set shell name to SHELL for profile management (default
                        $DETECTED_USER_SHELL)
  --username, -u USER   the name of the user to create in the kubeconfig
                        settings (default $USERNAME)
  --quiet, -q           do NOT print informative text (better for scripting)

Arguments:
  CONFIG_PATH           the path to the kubeconfig file that will be written
                        (default $KUBECONFIG_PATH)

This tool configures the kubectl command to work with the Kubernetes clusters
provided by Compute Platform.  It is idempotent, so it is safe to run
repeatedly, such as to fetch updated configuration for new clusters.

By default the kubeconfig containing all cluster, context, and user definitions
is MERGED into the file at CONFIG_PATH.  Notes regarding MERGING:

* Definitions in the downloaded kubeconfig take precedence when there are
  conflicts in the target kubeconfig
* Definitions for clusters and contexts that are no longer defined are
  NEVER purged from the target kubeconfig

Whether merging or overwriting the kubeconfig, any existing kubeconfig file is
preserved with a .previous extension.
	USAGE
}

die() {
	echo "$SCRIPT: $1" >&2
	exit 1
}

parse_args() {
	while [ $# -gt 0 ]; do
		case "$1" in
			--help|-h)
				usage
				exit
				;;
			--merge|-m)
				OVERWRITE_KUBECONFIG=false; shift
				;;
			--no-merge|-M)
				OVERWRITE_KUBECONFIG=true; shift
				;;
			--profile|-p)
				MANAGE_PROFILE=true; shift
				;;
			--no-profile|-P)
				MANAGE_PROFILE=false; shift
				;;
			--shell|-s)
				[ -z "$2" ] && die "no shell given for $1"
				USER_SHELL=$2; shift; shift
				;;
			--username|-u)
				[ -z "$2" ] && die "no name given for $1"
				USERNAME=$2; shift; shift
				;;
			--quiet|-q)
				QUIET=true; shift
				;;
			-*)
				die "unknown option: $1"
				;;
			*)
				break
				;;
		esac
	done

	[ $# -gt 0 ] && { KUBECONFIG_PATH=$1; shift; }

	[ $# -gt 0 ] && die 'too many arguments given'
}

announce() {
	[ $# -gt 0 ] && { printf "$@" | announce; return; }

	[ "$QUIET" = true ] && { cat >/dev/null; return; }
	cat
}

cleanup() {
	[ -z "$DOWNLOADED_CONFIG" ] || rm -f "$DOWNLOADED_CONFIG"
	[ -z "$MERGED_CONFIG" ] || rm -f "$MERGED_CONFIG"
}

is_osx() {
	[ "${OSTYPE:0:6}" = darwin ]
}

detect_user_shell() {
	if is_osx; then
		basename "$(dscl . -read /Users/${USER} UserShell | awk '{ print $2 }')"
	else
		basename "$(getent passwd $USER | cut -d: -f7)"
	fi
}

tempfile() {
	mkdir -p "$(dirname "$1")"
	mktemp "$1"
}

replace_kubeconfig() {
	if [ -e "$KUBECONFIG_PATH" ]; then
		cp "$KUBECONFIG_PATH" "$KUBECONFIG_PATH.previous" ||
			die 'failed to backup current kubeconfig'
	fi
	mv "$1" "$KUBECONFIG_PATH" || die 'failed to replace kubeconfig'
}

fetch_kubeconfig() {
	announce 'Downloading kubeconfig...\n'

	DOWNLOADED_CONFIG=$(tempfile "$KUBECONFIG_PATH.downloaded.XXXXXX") ||
		die 'failed to create temporary file for downloaded kubeconfig'
	curl -sfL -o "$DOWNLOADED_CONFIG" "$KUBECONFIG_API/$USERNAME" ||
		die 'failed to download kubeconfig to temporary file'
}

write_kubeconfig() {
	fetch_kubeconfig

	announce 'Writing downloaded kubeconfig into %s...\n' "$KUBECONFIG_PATH"

	replace_kubeconfig "$DOWNLOADED_CONFIG"
}

merge_kubeconfig() {
	fetch_kubeconfig

	announce 'Merging downloaded kubeconfig into %s...\n' "$KUBECONFIG_PATH"

	MERGED_CONFIG=$(tempfile "$KUBECONFIG_PATH.merged.XXXXXX") ||
		die 'failed to create temporary file for merged kubeconfig'
	KUBECONFIG="$DOWNLOADED_CONFIG:$KUBECONFIG_PATH" \
		kubectl config view --raw >"$MERGED_CONFIG" ||
		die 'failed to write merged kubeconfig'

	replace_kubeconfig "$MERGED_CONFIG"
}

save_kubeconfig() {
	if [ "$OVERWRITE_KUBECONFIG" = true ]; then
		write_kubeconfig
	else
		merge_kubeconfig
	fi
}

install_krew() {
	# Short circuit if krew is already installed.
	kubectl krew version >/dev/null 2>&1 && return

	announce 'Installing krew plugin...\n'
	(
	set -e
	cd "$(mktemp -d)"
	trap 'rm -r $(pwd)' EXIT
	OS="$(uname | tr '[:upper:]' '[:lower:]')"
	ARCH="$(uname -m | sed -e 's/x86_64/amd64/' -e 's/\(arm\)\(64\)\?.*/\1\2/' -e 's/aarch64$/arm64/')"
	KREW="krew-${OS}_${ARCH}"
	curl -fsSLO "https://github.com/kubernetes-sigs/krew/releases/latest/download/${KREW}.tar.gz"
	tar zxf "${KREW}.tar.gz"
	./"${KREW}" install krew
	) 2>&1 | announce
}

install_oidc_login() {
	# Short circuit if oidc-login is already installed.
	kubectl oidc-login version >/dev/null 2>&1 && return

	announce 'Installing oidc-login plugin...\n'
	kubectl krew install oidc-login 2>&1 | announce
}

install_kubectl_plugins() {
	(
	# Ensure that the krew installation path is in the PATH just in case.
	PATH=${KREW_ROOT:-$HOME/.krew}/bin:$PATH

	install_krew || die 'failed to install krew plugin'
	install_oidc_login || die 'failed to install oidc-login plugin'
	)
}

create_profile_fragment() {
	announce 'Writing shell profile fragment...\n'
	cat <<-EOF >"$PROFILE_FRAGMENT_PATH"
# This file was created by the $SCRIPT tool.  Changes made to this file
# will be lost.

export PATH="\${KREW_ROOT:-\$HOME/.krew}/bin:\$PATH"
	EOF
}

hook_profile_fragment() {
	HOOK=$(printf '. "%s"\n' "$PROFILE_FRAGMENT_PATH")
	case "$USER_SHELL" in
		bash)
			RC_FILE=$HOME/.bashrc
			;;
		zsh)
			RC_FILE=$HOME/.zshrc
			;;
		sh)
			RC_FILE=$HOME/.profile
			;;
		fish)
			RC_FILE=$HOME/.config/fish/extra.fish
			;;
		*)
			die "failed to hook profile fragment: unsupported shell: $USER_SHELL"
			return
			;;
	esac

	grep "$HOOK" "$RC_FILE" >/dev/null 2>&1 && return

	announce 'Hooking shell profile fragment into shell startup script...\n'
	printf '\n%s\n' "$HOOK" >>$RC_FILE
}

configure_profile() {
	[ "$MANAGE_PROFILE" = false ] && return

	create_profile_fragment || die 'failed to create profile fragment'
	hook_profile_fragment || die 'failed to hook profile fragment'
}

print_instructions() {
	# Do not nag the user if it looks like the profile fragment is already loaded.
	kubectl krew version >/dev/null 2>&1 && return

	if [ "$MANAGE_PROFILE" = true ]; then
		announce <<-EOM

In order to use kubectl in your currently running terminals or shells, run the
following in each open session:

	. "$PROFILE_FRAGMENT_PATH"
		EOM
	else
		announce <<-EOM

In order to use kubectl in your terminals or shells, ensure that
${KREW_ROOT:-$HOME/.krew}/bin is in your PATH.
		EOM
	fi
}

SCRIPT=$(basename "$0")
KUBECONFIG_API=https://kubernetes.indeed.tech/api/kubeconfig
USERNAME=$USER
KUBECONFIG_PATH=$HOME/.kube/config
OVERWRITE_KUBECONFIG=false
MANAGE_PROFILE=true
QUIET=false
DETECTED_USER_SHELL=$(detect_user_shell)
USER_SHELL=$DETECTED_USER_SHELL
PROFILE_FRAGMENT_PATH=$HOME/.indeed-kube-profile


parse_args "$@"

trap 'cleanup' EXIT

save_kubeconfig
install_kubectl_plugins
configure_profile
announce '\nConfiguration complete.\n'
print_instructions
